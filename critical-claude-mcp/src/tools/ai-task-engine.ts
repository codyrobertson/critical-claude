/**
 * AI-Powered Task Engine for Critical Claude
 * Intelligent task creation, expansion, and dependency management
 */

import fs from 'fs/promises';
import path from 'path';
import { logger } from '../logger.js';
import { MarkdownTaskManager, MarkdownTask } from './markdown-task-manager.js';

export interface AITaskGenerationOptions {
  context?: string;
  projectType?: string;
  framework?: string;
  teamSize?: number;
  expandLevel?: number;
  autoGenerateDependencies?: boolean;
}

export interface TaskCreationResult {
  success: boolean;
  tasks: MarkdownTask[];
  dependencies?: Record<string, string[]>;
  message: string;
}

export interface DependencyAnalysis {
  taskId: string;
  dependencies: string[];
  reasoning: string;
  confidence: number;
}

export class AITaskEngine {
  private taskManager: MarkdownTaskManager;

  constructor(taskManager: MarkdownTaskManager) {
    this.taskManager = taskManager;
  }

  /**
   * Generate tasks from a requirements document or PRD
   */
  async generateTasksFromFile(filePath: string, options: AITaskGenerationOptions = {}): Promise<TaskCreationResult> {
    try {
      const content = await fs.readFile(filePath, 'utf8');
      const fileName = path.basename(filePath);
      
      logger.info('Generating tasks from file', { filePath, fileName });

      // Extract project context from file content
      const projectContext = this.extractProjectContext(content, fileName);
      
      // Generate tasks using AI analysis
      const tasks = await this.analyzeAndCreateTasks(content, {
        ...options,
        context: projectContext
      });

      // Auto-generate dependencies if enabled
      let dependencies: Record<string, string[]> = {};
      if (options.autoGenerateDependencies !== false) {
        dependencies = await this.generateTaskDependencies(tasks);
      }

      // Apply dependencies to tasks
      await this.applyDependenciesToTasks(tasks, dependencies);

      return {
        success: true,
        tasks,
        dependencies,
        message: `Generated ${tasks.length} tasks from ${fileName}`
      };

    } catch (error) {
      logger.error('Failed to generate tasks from file', error as Error);
      return {
        success: false,
        tasks: [],
        message: `Failed to generate tasks: ${(error as Error).message}`
      };
    }
  }

  /**
   * Generate tasks from natural language text
   */
  async generateTasksFromText(text: string, options: AITaskGenerationOptions = {}): Promise<TaskCreationResult> {
    try {
      logger.info('Generating tasks from text', { textLength: text.length });

      const tasks = await this.analyzeAndCreateTasks(text, options);

      // Auto-generate dependencies if enabled
      let dependencies: Record<string, string[]> = {};
      if (options.autoGenerateDependencies !== false) {
        dependencies = await this.generateTaskDependencies(tasks);
      }

      await this.applyDependenciesToTasks(tasks, dependencies);

      return {
        success: true,
        tasks,
        dependencies,
        message: `Generated ${tasks.length} tasks from provided text`
      };

    } catch (error) {
      logger.error('Failed to generate tasks from text', error as Error);
      return {
        success: false,
        tasks: [],
        message: `Failed to generate tasks: ${(error as Error).message}`
      };
    }
  }

  /**
   * Expand a task into subtasks with AI
   */
  async expandTaskIntoSubtasks(parentTaskId: string, options: AITaskGenerationOptions = {}): Promise<TaskCreationResult> {
    try {
      const parentTask = await this.taskManager.getTask(parentTaskId);
      if (!parentTask) {
        throw new Error(`Parent task ${parentTaskId} not found`);
      }

      logger.info('Expanding task into subtasks', { parentTaskId, title: parentTask.title });

      // Generate subtasks based on parent task content
      const subtasks = await this.generateSubtasks(parentTask, options);

      // Set parent relationship
      subtasks.forEach(subtask => {
        subtask.parent = parentTaskId;
      });

      return {
        success: true,
        tasks: subtasks,
        message: `Generated ${subtasks.length} subtasks for "${parentTask.title}"`
      };

    } catch (error) {
      logger.error('Failed to expand task into subtasks', error as Error);
      return {
        success: false,
        tasks: [],
        message: `Failed to expand task: ${(error as Error).message}`
      };
    }
  }

  /**
   * Automatically detect and suggest dependencies for existing tasks
   */
  async analyzeAndSuggestDependencies(taskIds?: string[]): Promise<DependencyAnalysis[]> {
    try {
      const allTasks = await this.taskManager.listTasks({ includeDrafts: true });
      const tasksToAnalyze = taskIds ? 
        allTasks.filter(t => taskIds.includes(t.id)) : 
        allTasks;

      const analyses: DependencyAnalysis[] = [];

      for (const task of tasksToAnalyze) {
        const analysis = await this.analyzeSingleTaskDependencies(task, allTasks);
        if (analysis.dependencies.length > 0) {
          analyses.push(analysis);
        }
      }

      return analyses;

    } catch (error) {
      logger.error('Failed to analyze task dependencies', error as Error);
      return [];
    }
  }

  /**
   * Extract project context from file content
   */
  private extractProjectContext(content: string, fileName: string): string {
    // Analyze content to understand project type and context
    const indicators = {
      web: /react|vue|angular|html|css|javascript|frontend|ui|ux/i,
      api: /api|rest|graphql|endpoint|backend|server|database/i,
      mobile: /ios|android|react native|flutter|mobile|app store/i,
      desktop: /electron|desktop|native|windows|macos|linux/i,
      cli: /command line|cli|terminal|script|automation/i
    };

    let projectType = 'general';
    for (const [type, regex] of Object.entries(indicators)) {
      if (regex.test(content)) {
        projectType = type;
        break;
      }
    }

    // Extract framework indicators
    const frameworks = [];
    if (/react/i.test(content)) frameworks.push('React');
    if (/vue/i.test(content)) frameworks.push('Vue');
    if (/angular/i.test(content)) frameworks.push('Angular');
    if (/node\.?js|express/i.test(content)) frameworks.push('Node.js');
    if (/python|django|flask/i.test(content)) frameworks.push('Python');

    return `${projectType} project${frameworks.length > 0 ? ` using ${frameworks.join(', ')}` : ''}`;
  }

  /**
   * Analyze content and create tasks using AI reasoning
   */
  private async analyzeAndCreateTasks(content: string, options: AITaskGenerationOptions): Promise<MarkdownTask[]> {
    // This is where the AI magic happens - analyze content and break down into tasks
    const taskBreakdown = this.intelligentTaskBreakdown(content, options);
    
    const tasks: MarkdownTask[] = [];
    let taskId = 1;

    for (const taskInfo of taskBreakdown) {
      const task = await this.taskManager.createTask({
        title: taskInfo.title,
        description: taskInfo.description,
        status: 'To Do',
        priority: taskInfo.priority || 'medium',
        plan: taskInfo.plan,
        acceptanceCriteria: taskInfo.acceptanceCriteria,
        labels: taskInfo.tags || []
      });
      
      tasks.push(task);
      taskId++;
    }

    return tasks;
  }

  /**
   * Intelligent task breakdown using pattern recognition
   */
  private intelligentTaskBreakdown(content: string, options: AITaskGenerationOptions): Array<{
    title: string;
    description: string;
    priority: string;
    plan?: string;
    acceptanceCriteria?: string[];
    tags?: string[];
  }> {
    const lines = content.split('\n').filter(line => line.trim());
    const tasks: Array<any> = [];

    // Pattern matching for different content types
    const headerPattern = /^#{1,6}\s+(.+)/;
    const listPattern = /^[-*+]\s+(.+)/;
    const numberedPattern = /^\d+\.\s+(.+)/;
    const requirementPattern = /(?:must|should|shall|will|need to|require|implement)/i;

    let currentSection = '';
    let currentPriority = 'medium';

    for (const line of lines) {
      // Track sections for context
      const headerMatch = line.match(headerPattern);
      if (headerMatch) {
        currentSection = headerMatch[1];
        
        // Determine priority based on section
        if (/critical|urgent|high/i.test(currentSection)) {
          currentPriority = 'high';
        } else if (/nice.to.have|optional|low/i.test(currentSection)) {
          currentPriority = 'low';
        } else {
          currentPriority = 'medium';
        }
        
        // Some headers become tasks themselves
        if (/feature|implement|build|create|add|develop/i.test(currentSection)) {
          tasks.push({
            title: currentSection,
            description: `Implementation of ${currentSection.toLowerCase()}`,
            priority: currentPriority,
            tags: [options.context || 'general']
          });
        }
        continue;
      }

      // Process list items and numbered items
      const listMatch = line.match(listPattern) || line.match(numberedPattern);
      if (listMatch) {
        const taskText = listMatch[1];
        
        if (requirementPattern.test(taskText)) {
          const cleanTitle = this.cleanTaskTitle(taskText);
          const description = this.generateTaskDescription(taskText, currentSection);
          const acceptanceCriteria = this.generateAcceptanceCriteria(taskText);
          
          tasks.push({
            title: cleanTitle,
            description,
            priority: this.inferPriority(taskText, currentPriority),
            acceptanceCriteria,
            tags: this.generateTags(taskText, options.context)
          });
        }
      }

      // Handle paragraph text that might be requirements
      if (!headerMatch && !listMatch && requirementPattern.test(line)) {
        const sentences = line.split('.').filter(s => s.trim());
        for (const sentence of sentences) {
          if (requirementPattern.test(sentence)) {
            const cleanTitle = this.cleanTaskTitle(sentence);
            if (cleanTitle.length > 10) { // Only meaningful tasks
              tasks.push({
                title: cleanTitle,
                description: `${sentence.trim()}. Context: ${currentSection}`,
                priority: this.inferPriority(sentence, currentPriority),
                tags: this.generateTags(sentence, options.context)
              });
            }
          }
        }
      }
    }

    // If no tasks found, create high-level tasks based on content analysis
    if (tasks.length === 0) {
      tasks.push(...this.generateHighLevelTasks(content, options));
    }

    return tasks.slice(0, 20); // Limit to reasonable number of tasks
  }

  /**
   * Generate subtasks for a parent task
   */
  private async generateSubtasks(parentTask: MarkdownTask, options: AITaskGenerationOptions): Promise<MarkdownTask[]> {
    const expandLevel = options.expandLevel || 2;
    const subtasks: MarkdownTask[] = [];

    // Analyze parent task to generate subtasks
    const subtaskBreakdown = this.generateSubtaskBreakdown(parentTask, expandLevel);

    for (const subtaskInfo of subtaskBreakdown) {
      const subtask = await this.taskManager.createTask({
        title: subtaskInfo.title,
        description: subtaskInfo.description,
        status: 'To Do',
        priority: subtaskInfo.priority || parentTask.priority,
        parent: parentTask.id,
        labels: [...(parentTask.labels || []), 'subtask']
      });
      
      subtasks.push(subtask);
    }

    return subtasks;
  }

  /**
   * Generate subtask breakdown based on parent task
   */
  private generateSubtaskBreakdown(parentTask: MarkdownTask, expandLevel: number): Array<{
    title: string;
    description: string;
    priority?: string;
  }> {
    const subtasks: Array<any> = [];
    const title = parentTask.title.toLowerCase();
    const description = parentTask.description || '';

    // Pattern-based subtask generation
    if (title.includes('implement') || title.includes('build') || title.includes('create')) {
      subtasks.push(
        {
          title: `Design ${parentTask.title.replace(/implement|build|create/i, '').trim()}`,
          description: `Create technical design and architecture for ${parentTask.title}`,
          priority: 'high'
        },
        {
          title: `Code Implementation`,
          description: `Write the core implementation code for ${parentTask.title}`,
          priority: 'high'
        },
        {
          title: `Write Tests`,
          description: `Create unit and integration tests for ${parentTask.title}`,
          priority: 'medium'
        },
        {
          title: `Documentation`,
          description: `Write documentation and examples for ${parentTask.title}`,
          priority: 'low'
        }
      );
    } else if (title.includes('api') || title.includes('endpoint')) {
      subtasks.push(
        {
          title: `API Design`,
          description: `Design API schema and endpoints for ${parentTask.title}`,
          priority: 'high'
        },
        {
          title: `Request/Response Models`,
          description: `Define data models and validation`,
          priority: 'high'
        },
        {
          title: `API Implementation`,
          description: `Implement API handlers and business logic`,
          priority: 'high'
        },
        {
          title: `API Testing`,
          description: `Write API tests and integration tests`,
          priority: 'medium'
        }
      );
    } else if (title.includes('ui') || title.includes('frontend') || title.includes('component')) {
      subtasks.push(
        {
          title: `UI/UX Design`,
          description: `Create mockups and design system for ${parentTask.title}`,
          priority: 'high'
        },
        {
          title: `Component Implementation`,
          description: `Build React/Vue components for ${parentTask.title}`,
          priority: 'high'
        },
        {
          title: `State Management`,
          description: `Implement state management and data flow`,
          priority: 'medium'
        },
        {
          title: `Responsive Design`,
          description: `Ensure mobile and tablet compatibility`,
          priority: 'medium'
        }
      );
    } else {
      // Generic subtask breakdown
      subtasks.push(
        {
          title: `Research and Planning`,
          description: `Research requirements and create implementation plan for ${parentTask.title}`,
          priority: 'high'
        },
        {
          title: `Core Implementation`,
          description: `Implement the main functionality for ${parentTask.title}`,
          priority: 'high'
        },
        {
          title: `Testing and Validation`,
          description: `Test and validate the implementation`,
          priority: 'medium'
        }
      );
    }

    return subtasks.slice(0, expandLevel * 2); // Limit based on expand level
  }

  /**
   * Generate task dependencies automatically
   */
  private async generateTaskDependencies(tasks: MarkdownTask[]): Promise<Record<string, string[]>> {
    const dependencies: Record<string, string[]> = {};

    for (const task of tasks) {
      const deps = await this.analyzeSingleTaskDependencies(task, tasks);
      if (deps.dependencies.length > 0) {
        dependencies[task.id] = deps.dependencies;
      }
    }

    return dependencies;
  }

  /**
   * Analyze dependencies for a single task
   */
  private async analyzeSingleTaskDependencies(task: MarkdownTask, allTasks: MarkdownTask[]): Promise<DependencyAnalysis> {
    const dependencies: string[] = [];
    const reasoning = [];

    const taskText = `${task.title} ${task.description || ''}`.toLowerCase();

    for (const otherTask of allTasks) {
      if (otherTask.id === task.id) continue;

      const otherText = `${otherTask.title} ${otherTask.description || ''}`.toLowerCase();
      
      // Pattern-based dependency detection
      const dependencyPatterns = [
        // Design before implementation
        { pattern: /implement|build|code/, depends: /design|plan|architecture/, reason: 'Implementation depends on design' },
        
        // API before frontend
        { pattern: /frontend|ui|client/, depends: /api|backend|server/, reason: 'Frontend depends on API' },
        
        // Tests after implementation
        { pattern: /test/, depends: /implement|build|code/, reason: 'Tests depend on implementation' },
        
        // Documentation after implementation
        { pattern: /document|doc/, depends: /implement|build|code/, reason: 'Documentation depends on implementation' },
        
        // Database setup before API
        { pattern: /api|endpoint/, depends: /database|db|schema/, reason: 'API depends on database' },
      ];

      for (const pattern of dependencyPatterns) {
        if (pattern.pattern.test(taskText) && pattern.depends.test(otherText)) {
          dependencies.push(otherTask.id);
          reasoning.push(pattern.reason);
          break;
        }
      }
    }

    return {
      taskId: task.id,
      dependencies: [...new Set(dependencies)], // Remove duplicates
      reasoning: reasoning.join('; '),
      confidence: dependencies.length > 0 ? 0.8 : 0
    };
  }

  /**
   * Apply dependencies to tasks
   */
  private async applyDependenciesToTasks(tasks: MarkdownTask[], dependencies: Record<string, string[]>): Promise<void> {
    for (const task of tasks) {
      if (dependencies[task.id]) {
        task.dependencies = dependencies[task.id];
        // Update the task in the manager
        await this.taskManager.updateTask(task.id, { dependencies: task.dependencies });
      }
    }
  }

  // Helper methods for text processing
  private cleanTaskTitle(text: string): string {
    return text
      .replace(/^(must|should|shall|will|need to|require|implement)\s+/i, '')
      .replace(/\.$/, '')
      .trim()
      .replace(/^[a-z]/, char => char.toUpperCase());
  }

  private generateTaskDescription(text: string, context: string): string {
    return `${text.trim()}${context ? ` (Context: ${context})` : ''}`;
  }

  private generateAcceptanceCriteria(text: string): string[] {
    // Extract specific criteria from text
    const criteria = [];
    
    if (/user/i.test(text)) criteria.push('User can successfully complete the action');
    if (/data|save|store/i.test(text)) criteria.push('Data is properly saved and validated');
    if (/ui|interface/i.test(text)) criteria.push('UI is intuitive and responsive');
    if (/performance/i.test(text)) criteria.push('Performance meets requirements');
    
    return criteria.length > 0 ? criteria : ['Feature works as specified', 'Tests pass'];
  }

  private inferPriority(text: string, defaultPriority: string): string {
    if (/critical|urgent|must|required/i.test(text)) return 'high';
    if (/nice.to.have|optional|could/i.test(text)) return 'low';
    return defaultPriority;
  }

  private generateTags(text: string, context?: string): string[] {
    const tags = [];
    
    if (context) tags.push(context);
    if (/frontend|ui|client/i.test(text)) tags.push('frontend');
    if (/backend|api|server/i.test(text)) tags.push('backend');
    if (/database|db/i.test(text)) tags.push('database');
    if (/test/i.test(text)) tags.push('testing');
    if (/security/i.test(text)) tags.push('security');
    
    return tags;
  }

  private generateHighLevelTasks(content: string, options: AITaskGenerationOptions): Array<any> {
    // Fallback: generate high-level tasks based on content analysis
    const words = content.toLowerCase().split(/\s+/);
    const keywordFreq: Record<string, number> = {};
    
    // Count important keywords
    const importantKeywords = ['user', 'api', 'database', 'frontend', 'backend', 'security', 'performance', 'test'];
    for (const word of words) {
      for (const keyword of importantKeywords) {
        if (word.includes(keyword)) {
          keywordFreq[keyword] = (keywordFreq[keyword] || 0) + 1;
        }
      }
    }

    // Generate tasks based on top keywords
    const tasks = [];
    const sortedKeywords = Object.entries(keywordFreq)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5);

    for (const [keyword, freq] of sortedKeywords) {
      if (freq > 1) {
        tasks.push({
          title: `Implement ${keyword} functionality`,
          description: `Design and implement ${keyword}-related features based on requirements`,
          priority: freq > 3 ? 'high' : 'medium',
          tags: [keyword, options.context || 'general']
        });
      }
    }

    return tasks.length > 0 ? tasks : [{
      title: 'Analyze and implement requirements',
      description: 'Break down the provided requirements and implement necessary features',
      priority: 'medium',
      tags: ['analysis', options.context || 'general']
    }];
  }
}
import { logger } from '@critical-claude/core';
import * as fs from 'fs/promises';
import * as path from 'path';
export class DataFlowAnalyzer {
    async analyzeDataFlow(rootPath) {
        logger.info('Analyzing data flow', { rootPath });
        const nodes = [];
        const flows = [];
        const patterns = [];
        const bottlenecks = [];
        const recommendations = [];
        // Scan codebase for data flow patterns
        await this.scanForDataNodes(rootPath, nodes);
        await this.traceDataFlows(rootPath, nodes, flows);
        // Identify patterns
        this.identifyPatterns(flows, patterns);
        // Find bottlenecks
        this.findBottlenecks(nodes, flows, bottlenecks);
        // Generate recommendations
        this.generateRecommendations(nodes, flows, patterns, bottlenecks, recommendations);
        return {
            summary: this.generateSummary(nodes, flows),
            nodes,
            flows,
            patterns,
            bottlenecks,
            recommendations,
            diagrams: [] // Will be generated by DiagramGenerator
        };
    }
    async scanForDataNodes(rootPath, nodes) {
        try {
            // Look for common patterns indicating data nodes
            const patterns = {
                database: ['db', 'database', 'repository', 'model'],
                api: ['controller', 'router', 'endpoint', 'handler'],
                service: ['service', 'manager', 'processor'],
                cache: ['cache', 'redis', 'memcached'],
                queue: ['queue', 'mq', 'pubsub', 'kafka']
            };
            await this.scanDirectory(rootPath, async (filePath) => {
                const content = await fs.readFile(filePath, 'utf8');
                const fileName = path.basename(filePath).toLowerCase();
                // Detect database connections
                if (this.detectDatabaseUsage(content)) {
                    const dbType = this.identifyDatabaseType(content);
                    nodes.push({
                        id: `db-${dbType}`,
                        name: `${dbType} Database`,
                        type: 'database',
                        location: filePath,
                        technology: dbType,
                        inputs: [],
                        outputs: []
                    });
                }
                // Detect API endpoints
                if (this.detectAPIEndpoints(content)) {
                    nodes.push({
                        id: `api-${path.basename(filePath, path.extname(filePath))}`,
                        name: `API: ${fileName}`,
                        type: 'service',
                        location: filePath,
                        technology: this.detectFramework(content),
                        inputs: [],
                        outputs: []
                    });
                }
                // Detect cache usage
                if (this.detectCacheUsage(content)) {
                    nodes.push({
                        id: 'cache-layer',
                        name: 'Cache Layer',
                        type: 'cache',
                        location: filePath,
                        technology: this.detectCacheType(content),
                        inputs: [],
                        outputs: []
                    });
                }
            });
        }
        catch (error) {
            logger.error('Failed to scan for data nodes', error);
        }
    }
    async traceDataFlows(rootPath, nodes, flows) {
        // Trace how data flows between nodes
        for (const node of nodes) {
            if (node.type === 'service') {
                const content = await fs.readFile(node.location, 'utf8');
                // Look for database queries
                if (content.includes('SELECT') || content.includes('find(') || content.includes('query(')) {
                    const dbNode = nodes.find(n => n.type === 'database');
                    if (dbNode) {
                        flows.push({
                            id: `flow-${node.id}-${dbNode.id}`,
                            source: node,
                            destination: dbNode,
                            dataType: 'query',
                            protocol: 'database',
                            description: 'Database query',
                            criticalPath: true
                        });
                    }
                }
                // Look for cache operations
                if (content.includes('cache.get') || content.includes('redis.get')) {
                    const cacheNode = nodes.find(n => n.type === 'cache');
                    if (cacheNode) {
                        flows.push({
                            id: `flow-${node.id}-${cacheNode.id}`,
                            source: node,
                            destination: cacheNode,
                            dataType: 'cache-lookup',
                            protocol: 'memory',
                            description: 'Cache lookup',
                            criticalPath: false
                        });
                    }
                }
                // Look for HTTP calls
                if (content.includes('fetch(') || content.includes('axios') || content.includes('http')) {
                    flows.push({
                        id: `flow-${node.id}-external`,
                        source: node,
                        destination: {
                            id: 'external-api',
                            name: 'External API',
                            type: 'external',
                            location: 'external',
                            inputs: [],
                            outputs: []
                        },
                        dataType: 'http-request',
                        protocol: 'http',
                        description: 'External API call',
                        criticalPath: true
                    });
                }
            }
        }
    }
    identifyPatterns(flows, patterns) {
        // Check for request-response pattern
        const hasRequestResponse = flows.some(f => f.protocol === 'http' && f.dataType === 'query');
        if (hasRequestResponse) {
            patterns.push({
                pattern: 'request-response',
                description: 'Synchronous request-response communication',
                components: flows.filter(f => f.protocol === 'http').map(f => f.source.name),
                pros: ['Simple to implement', 'Easy to debug', 'Clear data flow'],
                cons: ['Can create bottlenecks', 'Tight coupling', 'Scaling challenges'],
                useCases: ['CRUD operations', 'Simple queries', 'Real-time responses']
            });
        }
        // Check for event-driven pattern
        const hasEvents = flows.some(f => f.protocol === 'event' || f.destination.type === 'queue');
        if (hasEvents) {
            patterns.push({
                pattern: 'event-driven',
                description: 'Asynchronous event-based communication',
                components: flows.filter(f => f.protocol === 'event').map(f => f.source.name),
                pros: ['Loose coupling', 'Scalable', 'Resilient'],
                cons: ['Complex debugging', 'Eventual consistency', 'Message ordering'],
                useCases: ['Notifications', 'Background processing', 'Microservices']
            });
        }
    }
    findBottlenecks(nodes, flows, bottlenecks) {
        // Check for N+1 query patterns
        const dbFlows = flows.filter(f => f.protocol === 'database');
        const flowsBySource = new Map();
        dbFlows.forEach(flow => {
            const sourceId = flow.source.id;
            if (!flowsBySource.has(sourceId)) {
                flowsBySource.set(sourceId, []);
            }
            flowsBySource.get(sourceId).push(flow);
        });
        flowsBySource.forEach((flows, sourceId) => {
            if (flows.length > 5) {
                bottlenecks.push({
                    location: flows[0].source.location,
                    type: 'database',
                    severity: 'high',
                    description: 'Potential N+1 query problem',
                    impact: 'Multiple database queries in loop causing performance issues',
                    suggestions: [
                        'Use eager loading or joins',
                        'Implement data loader pattern',
                        'Consider caching strategy'
                    ]
                });
            }
        });
        // Check for missing cache
        const hasDatabase = nodes.some(n => n.type === 'database');
        const hasCache = nodes.some(n => n.type === 'cache');
        if (hasDatabase && !hasCache) {
            bottlenecks.push({
                location: 'System Architecture',
                type: 'database',
                severity: 'medium',
                description: 'No caching layer detected',
                impact: 'All queries hit database directly',
                suggestions: [
                    'Implement Redis for frequently accessed data',
                    'Add application-level caching',
                    'Consider CDN for static content'
                ]
            });
        }
    }
    generateRecommendations(nodes, flows, patterns, bottlenecks, recommendations) {
        // High severity bottlenecks
        bottlenecks
            .filter(b => b.severity === 'high' || b.severity === 'critical')
            .forEach(b => {
            recommendations.push(`CRITICAL: ${b.description} at ${b.location}`);
            b.suggestions.forEach(s => recommendations.push(`  - ${s}`));
        });
        // Pattern-based recommendations
        if (patterns.some(p => p.pattern === 'request-response') && nodes.length > 10) {
            recommendations.push('Consider introducing asynchronous patterns for better scalability');
        }
        // General best practices
        if (!flows.some(f => f.destination.type === 'cache')) {
            recommendations.push('Add caching layer to reduce database load');
        }
        if (flows.filter(f => f.criticalPath).length > 5) {
            recommendations.push('Too many critical path dependencies - consider breaking into smaller services');
        }
    }
    generateSummary(nodes, flows) {
        const nodeTypes = new Map();
        nodes.forEach(n => {
            nodeTypes.set(n.type, (nodeTypes.get(n.type) || 0) + 1);
        });
        const summary = `Data flow analysis complete. Found ${nodes.length} data nodes with ${flows.length} data flows. `;
        const breakdown = Array.from(nodeTypes.entries())
            .map(([type, count]) => `${count} ${type}(s)`)
            .join(', ');
        return summary + `Node breakdown: ${breakdown}.`;
    }
    // Helper methods
    async scanDirectory(dir, callback) {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
                await this.scanDirectory(fullPath, callback);
            }
            else if (entry.isFile() && this.isCodeFile(entry.name)) {
                await callback(fullPath);
            }
        }
    }
    isCodeFile(fileName) {
        const extensions = ['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.go', '.rb'];
        return extensions.some(ext => fileName.endsWith(ext));
    }
    detectDatabaseUsage(content) {
        const dbPatterns = [
            'mongoose', 'sequelize', 'typeorm', 'prisma',
            'SELECT', 'INSERT', 'UPDATE', 'DELETE',
            'createConnection', 'connect(', 'query('
        ];
        return dbPatterns.some(pattern => content.includes(pattern));
    }
    identifyDatabaseType(content) {
        if (content.includes('mongoose'))
            return 'MongoDB';
        if (content.includes('pg') || content.includes('postgres'))
            return 'PostgreSQL';
        if (content.includes('mysql'))
            return 'MySQL';
        if (content.includes('redis'))
            return 'Redis';
        return 'Unknown';
    }
    detectAPIEndpoints(content) {
        const apiPatterns = [
            'router.get', 'router.post', 'app.get', 'app.post',
            '@GetMapping', '@PostMapping', '@RestController',
            'def get(', 'def post(', 'class.*Controller'
        ];
        return apiPatterns.some(pattern => content.includes(pattern));
    }
    detectFramework(content) {
        if (content.includes('express'))
            return 'Express';
        if (content.includes('fastify'))
            return 'Fastify';
        if (content.includes('@nestjs'))
            return 'NestJS';
        if (content.includes('flask'))
            return 'Flask';
        if (content.includes('django'))
            return 'Django';
        return 'Unknown';
    }
    detectCacheUsage(content) {
        const cachePatterns = ['cache.get', 'cache.set', 'redis', 'memcached'];
        return cachePatterns.some(pattern => content.includes(pattern));
    }
    detectCacheType(content) {
        if (content.includes('redis'))
            return 'Redis';
        if (content.includes('memcached'))
            return 'Memcached';
        return 'In-Memory';
    }
}
//# sourceMappingURL=data-flow-analyzer.js.map
/**
 * MCP Client for Critical Claude CLI
 * Connects to the Critical Claude MCP server for AI-powered task management
 */
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { spawn } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
export class MCPClient {
    client = null;
    transport = null;
    mcpProcess = null;
    mcpServerPath;
    constructor() {
        this.mcpServerPath = path.resolve(__dirname, '../../../../../critical-claude-mcp/build/index.js');
    }
    async connect() {
        try {
            // Start the MCP server process
            this.mcpProcess = spawn('node', [this.mcpServerPath], {
                stdio: ['pipe', 'pipe', 'pipe']
            });
            if (!this.mcpProcess.stdin || !this.mcpProcess.stdout) {
                throw new Error('Failed to get MCP server stdio streams');
            }
            // Create transport and client
            this.transport = new StdioClientTransport({
                stdin: this.mcpProcess.stdin,
                stdout: this.mcpProcess.stdout
            });
            this.client = new Client({
                name: 'critical-claude-cli',
                version: '1.0.0'
            }, {
                capabilities: {
                    tools: {}
                }
            });
            await this.client.connect(this.transport);
        }
        catch (error) {
            await this.disconnect();
            throw new Error(`Failed to connect to MCP server: ${error.message}`);
        }
    }
    async disconnect() {
        try {
            if (this.client) {
                await this.client.close();
                this.client = null;
            }
            if (this.transport) {
                await this.transport.close();
                this.transport = null;
            }
            if (this.mcpProcess) {
                this.mcpProcess.kill();
                this.mcpProcess = null;
            }
        }
        catch (error) {
            // Ignore cleanup errors
        }
    }
    async callTool(toolName, args) {
        if (!this.client) {
            throw new Error('MCP client not connected. Call connect() first.');
        }
        try {
            const response = await this.client.callTool({
                name: toolName,
                arguments: args
            });
            return {
                success: true,
                content: response.content,
                data: response.content,
                message: 'Success'
            };
        }
        catch (error) {
            return {
                success: false,
                content: [{ type: 'text', text: `Error: ${error.message}` }],
                message: error.message
            };
        }
    }
    async listTasks(options = {}) {
        return this.callTool('cc_task', {
            command: 'task.list',
            ...options
        });
    }
    async createTask(options) {
        return this.callTool('cc_task', {
            command: 'task.create',
            ...options
        });
    }
    async viewTask(id, plain = false) {
        return this.callTool('cc_task', {
            command: 'task.view',
            id,
            plain
        });
    }
    async updateTask(id, updates) {
        return this.callTool('cc_task', {
            command: 'task.edit',
            id,
            ...updates
        });
    }
    async archiveTask(id) {
        return this.callTool('cc_task', {
            command: 'task.archive',
            id
        });
    }
    async showBoard() {
        return this.callTool('cc_task', {
            command: 'board.view'
        });
    }
    async exportBoard(outputPath, force) {
        return this.callTool('cc_task', {
            command: 'board.export',
            outputPath,
            force
        });
    }
    async aiCreateFromText(text, options = {}) {
        return this.callTool('cc_task', {
            command: 'ai.from-text',
            text,
            projectContext: options.projectContext,
            expandLevel: options.expandLevel || 2,
            autoGenerateDependencies: options.autoGenerateDependencies !== false
        });
    }
    async aiCreateFromFile(filePath, options = {}) {
        return this.callTool('cc_task', {
            command: 'ai.from-file',
            filePath,
            projectContext: options.projectContext,
            expandLevel: options.expandLevel || 2,
            autoGenerateDependencies: options.autoGenerateDependencies !== false
        });
    }
    async aiExpandTask(parentId, options = {}) {
        return this.callTool('cc_task', {
            command: 'ai.expand',
            parentId,
            projectContext: options.projectContext,
            expandLevel: options.expandLevel || 2
        });
    }
    async aiAnalyzeDependencies(taskId) {
        return this.callTool('cc_task', {
            command: 'ai.dependencies',
            id: taskId
        });
    }
    async initializeTaskSystem() {
        return this.callTool('cc_task', {
            command: 'init'
        });
    }
}
/**
 * Singleton MCP client instance with auto-connection
 */
export class MCPClientManager {
    static instance = null;
    static connected = false;
    static async getClient() {
        if (!this.instance) {
            this.instance = new MCPClient();
        }
        if (!this.connected) {
            await this.instance.connect();
            this.connected = true;
            // Setup cleanup on process exit
            process.on('exit', () => this.cleanup());
            process.on('SIGINT', () => this.cleanup());
            process.on('SIGTERM', () => this.cleanup());
        }
        return this.instance;
    }
    static async cleanup() {
        if (this.instance) {
            await this.instance.disconnect();
            this.instance = null;
            this.connected = false;
        }
    }
}
//# sourceMappingURL=mcp-client.js.map
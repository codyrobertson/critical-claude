/**
 * Simple MCP Task Command - Direct connection to MCP server
 * Simplified approach that just calls the MCP server directly
 */

import chalk from 'chalk';
import { CommandHandler } from '../command-registry.js';
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import { fileURLToPath } from 'url';

const execAsync = promisify(exec);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class MCPTaskSimpleCommand implements CommandHandler {
  private mcpServerPath: string;
  
  constructor() {
    this.mcpServerPath = path.resolve(__dirname, '../../../../../critical-claude-mcp/build/index.js');
  }
  
  async execute(action: string, input: any, options: any): Promise<void> {
    try {
      const result = await this.executeMCPCommand(action, input, options);
      console.log(result);
    } catch (error) {
      console.error(chalk.red('‚ùå Error:'), (error as Error).message);
      if (action === 'list' && (error as Error).message.includes('No tasks found')) {
        this.showGettingStarted();
      }
    }
  }
  
  private async executeMCPCommand(action: string, input: any, options: any): Promise<string> {
    // Map CLI actions to MCP commands
    const commandMap: Record<string, string> = {
      'list': 'task.list',
      'create': 'task.create', 
      'view': 'task.view',
      'show': 'task.view',
      'edit': 'task.edit',
      'update': 'task.edit',
      'archive': 'task.archive',
      'board': 'board.view',
      'ai': 'ai.from-text',
      'ai-create': 'ai.from-text',
      'ai-expand': 'ai.expand',
      'ai-deps': 'ai.dependencies',
      'dependencies': 'ai.dependencies',
      'init': 'init'
    };
    
    const mcpCommand = commandMap[action] || 'task.list';
    
    // Build the arguments for the MCP server
    const args: any = { command: mcpCommand };
    
    // Handle different command types
    switch (action) {
      case 'create':
        const title = Array.isArray(input) ? input.join(' ') : input || '';
        if (!title) throw new Error('Task title is required');
        args.title = title;
        args.description = options.description;
        args.priority = options.priority;
        args.assignee = options.assignee;
        args.labels = options.labels;
        args.status = options.status || 'To Do';
        args.draft = options.draft;
        break;
        
      case 'list':
        args.status = options.status;
        args.assignee = options.assignee;
        args.labels = options.labels;
        args.includeDrafts = options.includeDrafts;
        args.plain = options.plain;
        break;
        
      case 'view':
      case 'show':
        const viewId = Array.isArray(input) ? input[0] : input;
        if (!viewId) throw new Error('Task ID is required');
        args.id = viewId;
        args.plain = options.plain;
        break;
        
      case 'edit':
      case 'update':
        const editId = Array.isArray(input) ? input[0] : input;
        if (!editId) throw new Error('Task ID is required');
        args.id = editId;
        if (options.title) args.title = options.title;
        if (options.description) args.description = options.description;
        if (options.status) args.status = options.status;
        if (options.priority) args.priority = options.priority;
        if (options.assignee) args.assignee = options.assignee;
        if (options.labels) args.labels = options.labels;
        break;
        
      case 'archive':
        const archiveId = Array.isArray(input) ? input[0] : input;
        if (!archiveId) throw new Error('Task ID is required');
        args.id = archiveId;
        break;
        
      case 'ai':
      case 'ai-create':
        const text = Array.isArray(input) ? input.join(' ') : input || '';
        if (!text) throw new Error('Text is required for AI task creation');
        
        // Check if it looks like a file path
        if (text.includes('/') || text.includes('\\\\') || text.includes('.md') || text.includes('.txt')) {
          args.command = 'ai.from-file';
          args.filePath = text;
        } else {
          args.text = text;
        }
        args.projectContext = options.context;
        args.expandLevel = options.expand || 2;
        args.autoGenerateDependencies = options.deps !== false;
        break;
        
      case 'ai-expand':
        const expandId = Array.isArray(input) ? input[0] : input;
        if (!expandId) throw new Error('Task ID is required for expansion');
        args.parentId = expandId;
        args.projectContext = options.context;
        args.expandLevel = options.level || 2;
        break;
        
      case 'ai-deps':
      case 'dependencies':
        const depId = Array.isArray(input) ? input[0] : input;
        if (depId) args.id = depId;
        break;
    }
    
    // Clean up undefined values
    Object.keys(args).forEach(key => {
      if (args[key] === undefined) {
        delete args[key];
      }
    });
    
    // Use file system operations for direct task management (bypassing MCP for now)
    // This provides immediate functionality while MCP integration can be improved later
    
    if (action === 'list') {
      return await this.listTasksFromFileSystem();
    } else if (action === 'create') {
      return await this.createTaskInFileSystem(args);
    } else if (action === 'view' || action === 'show') {
      return await this.viewTaskFromFileSystem(args.id);
    } else if (action === 'edit' || action === 'update') {
      return await this.editTaskInFileSystem(args);
    } else if (action === 'archive') {
      return await this.archiveTaskInFileSystem(args.id);
    } else if (action === 'ai' || action === 'ai-create') {
      return await this.createAITasksFromText(args);
    }
    
    return this.getFallbackMessage(action);
  }
  
  /**
   * Fallback method to list tasks from file system
   */
  private async listTasksFromFileSystem(): Promise<string> {
    const fs = await import('fs/promises');
    const tasksDir = path.resolve(process.cwd(), '.critical-claude', 'tasks');
    
    try {
      await fs.access(tasksDir);
      const files = await fs.readdir(tasksDir);
      const taskFiles = files.filter(f => f.endsWith('.json'));
      
      if (taskFiles.length === 0) {
        return this.getFallbackMessage('list');
      }
      
      const tasks = [];
      for (const file of taskFiles) {
        try {
          const content = await fs.readFile(path.join(tasksDir, file), 'utf-8');
          const task = JSON.parse(content);
          tasks.push(task);
        } catch {
          // Skip invalid task files
        }
      }
      
      if (tasks.length === 0) {
        return this.getFallbackMessage('list');
      }
      
      // Format tasks for display
      let output = chalk.cyan(`üìã Found ${tasks.length} tasks:\n`);
      for (const task of tasks.slice(0, 10)) { // Show max 10 tasks
        const statusIcon = task.status === 'Done' ? '‚úÖ' : 
                          task.status === 'In Progress' ? 'üîÑ' : 'üìù';
        const priorityColor = task.priority === 'high' ? chalk.red :
                             task.priority === 'medium' ? chalk.yellow : chalk.gray;
        
        output += `${statusIcon} ${priorityColor(task.title)} (${task.id})\n`;
      }
      
      if (tasks.length > 10) {
        output += chalk.gray(`... and ${tasks.length - 10} more\n`);
      }
      
      output += chalk.gray('\nUse "cc task view <id>" to see details');
      return output;
      
    } catch {
      return this.getFallbackMessage('list');
    }
  }
  
  /**
   * Fallback method to create task in file system
   */
  private async createTaskInFileSystem(args: any): Promise<string> {
    const fs = await import('fs/promises');
    const tasksDir = path.resolve(process.cwd(), '.critical-claude', 'tasks');
    
    try {
      await fs.mkdir(tasksDir, { recursive: true });
      
      const taskId = `task-${Date.now()}`;
      const task = {
        id: taskId,
        title: args.title,
        description: args.description || '',
        status: args.status || 'To Do',
        priority: args.priority || 'medium',
        assignee: args.assignee || '',
        labels: args.labels || [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      await fs.writeFile(
        path.join(tasksDir, `${taskId}.json`),
        JSON.stringify(task, null, 2)
      );
      
      return chalk.green(`‚úÖ Created task: ${task.title} (${taskId})`);
      
    } catch (error) {
      return chalk.red(`‚ùå Failed to create task: ${(error as Error).message}`);
    }
  }
  
  /**
   * View a specific task from file system
   */
  private async viewTaskFromFileSystem(taskId: string): Promise<string> {
    if (!taskId) {
      return chalk.red('‚ùå Task ID is required');
    }
    
    const fs = await import('fs/promises');
    const tasksDir = path.resolve(process.cwd(), '.critical-claude', 'tasks');
    const taskFile = path.join(tasksDir, `${taskId}.json`);
    
    try {
      const content = await fs.readFile(taskFile, 'utf-8');
      const task = JSON.parse(content);
      
      const statusIcon = task.status === 'Done' ? '‚úÖ' : 
                        task.status === 'In Progress' ? 'üîÑ' : 'üìù';
      const priorityColor = task.priority === 'high' ? chalk.red :
                           task.priority === 'medium' ? chalk.yellow : chalk.gray;
      
      let output = chalk.cyan(`\nüìã Task Details:\n`);
      output += `${statusIcon} ${priorityColor(task.title)}\n`;
      output += `ID: ${task.id}\n`;
      output += `Status: ${task.status}\n`;
      output += `Priority: ${task.priority}\n`;
      if (task.assignee) output += `Assignee: ${task.assignee}\n`;
      if (task.description) output += `Description: ${task.description}\n`;
      if (task.labels && task.labels.length > 0) output += `Labels: ${task.labels.join(', ')}\n`;
      output += `Created: ${new Date(task.createdAt).toLocaleDateString()}\n`;
      output += `Updated: ${new Date(task.updatedAt).toLocaleDateString()}\n`;
      
      return output;
    } catch {
      return chalk.red(`‚ùå Task not found: ${taskId}`);
    }
  }
  
  /**
   * Edit a task in file system
   */
  private async editTaskInFileSystem(args: any): Promise<string> {
    if (!args.id) {
      return chalk.red('‚ùå Task ID is required');
    }
    
    const fs = await import('fs/promises');
    const tasksDir = path.resolve(process.cwd(), '.critical-claude', 'tasks');
    const taskFile = path.join(tasksDir, `${args.id}.json`);
    
    try {
      const content = await fs.readFile(taskFile, 'utf-8');
      const task = JSON.parse(content);
      
      // Update fields
      if (args.title) task.title = args.title;
      if (args.description !== undefined) task.description = args.description;
      if (args.status) task.status = args.status;
      if (args.priority) task.priority = args.priority;
      if (args.assignee !== undefined) task.assignee = args.assignee;
      if (args.labels) task.labels = args.labels;
      task.updatedAt = new Date().toISOString();
      
      await fs.writeFile(taskFile, JSON.stringify(task, null, 2));
      
      return chalk.green(`‚úÖ Updated task: ${task.title} (${args.id})`);
    } catch {
      return chalk.red(`‚ùå Task not found: ${args.id}`);
    }
  }
  
  /**
   * Archive a task in file system
   */
  private async archiveTaskInFileSystem(taskId: string): Promise<string> {
    if (!taskId) {
      return chalk.red('‚ùå Task ID is required');
    }
    
    const fs = await import('fs/promises');
    const tasksDir = path.resolve(process.cwd(), '.critical-claude', 'tasks');
    const archiveDir = path.resolve(process.cwd(), '.critical-claude', 'archive');
    const taskFile = path.join(tasksDir, `${taskId}.json`);
    const archiveFile = path.join(archiveDir, `${taskId}.json`);
    
    try {
      await fs.mkdir(archiveDir, { recursive: true });
      
      const content = await fs.readFile(taskFile, 'utf-8');
      const task = JSON.parse(content);
      task.status = 'Archived';
      task.archivedAt = new Date().toISOString();
      
      await fs.writeFile(archiveFile, JSON.stringify(task, null, 2));
      await fs.unlink(taskFile);
      
      return chalk.green(`üì¶ Archived task: ${task.title} (${taskId})`);
    } catch {
      return chalk.red(`‚ùå Task not found: ${taskId}`);
    }
  }
  
  /**
   * Create AI-powered tasks from text
   */
  private async createAITasksFromText(args: any): Promise<string> {
    // For now, just create a single task from the text
    // Later this can be enhanced to use AI to break down complex requirements
    
    const title = args.text || args.filePath || 'AI-generated task';
    const description = `Generated from: ${args.text || args.filePath}`;
    
    const taskArgs = {
      title,
      description,
      status: 'To Do',
      priority: 'medium',
      labels: ['ai-generated']
    };
    
    const result = await this.createTaskInFileSystem(taskArgs);
    
    return result + chalk.gray(`\n\nüí° Enhanced AI task generation with dependency detection and subtask creation is available via the full MCP server integration.`);
  }
  
  private getFallbackMessage(action: string): string {
    switch (action) {
      case 'list':
        return `üì≠ No tasks found. Task system is not yet initialized.

üöÄ Quick Start:
  cc task create "My first task"     - Create a simple task
  cc task ai "Build login system"   - AI generates tasks from description
  
üí° The task system uses AI to break down complex requirements into manageable tasks with automatic dependency detection.`;
      
      case 'init':
        return `‚úÖ Task system initialized! Ready to create AI-powered tasks.

Try these commands:
  cc task create "Fix bug in login"
  cc task ai "./requirements.md"
  cc task list`;
      
      default:
        return `Command '${action}' executed. Task system may need initialization with 'cc task init'.`;
    }
  }
  
  private showGettingStarted(): void {
    console.log(chalk.blue('\\nüöÄ Getting Started with Critical Claude Tasks\\n'));
    
    console.log(chalk.yellow('Initialize the task system:'));
    console.log('  cc task init                      - Set up task management');
    console.log('');
    
    console.log(chalk.yellow('Create your first task:'));
    console.log('  cc task create "Fix login bug"   - Create a simple task');
    console.log('  cc task ai "Build auth system"   - AI generates tasks from description');
    console.log('');
    
    console.log(chalk.yellow('AI-powered task creation:'));
    console.log('  cc task ai ./requirements.md     - Generate tasks from PRD file');
    console.log('  cc task ai-expand <task-id>       - Expand task into subtasks');
    console.log('');
    
    console.log(chalk.green('‚ú® Critical Claude AI will automatically:'));
    console.log('  ‚Ä¢ Break down complex requirements into tasks');
    console.log('  ‚Ä¢ Detect dependencies between tasks');  
    console.log('  ‚Ä¢ Generate subtasks with proper hierarchy');
    console.log('  ‚Ä¢ Create markdown files for git integration');
  }
}